#!/usr/bin/env python3
"""Export the local SQLite DB contents as Postgres-compatible SQL.

Use this when you canâ€™t connect directly to Supabase from your machine (e.g. DNS),
but you can paste SQL into the Supabase SQL editor.

Typical flow:
  1) Ensure tables exist in Supabase (deploy backend, or create schema).
  2) Run this script to generate `supabase_seed.sql`.
  3) Paste/run the SQL in Supabase.

This exports data only (no schema).
"""

from __future__ import annotations

import argparse
import sqlite3
from pathlib import Path
from typing import Any


TABLES_IN_FK_ORDER: list[str] = [
    "invite_codes",
    "users",
    "epub_progress",
    "listening_progress",
    "bookmarks",
    "notes",
    "epub_bookmarks",
    "epub_notes",
    "feedback",
]

# Heuristic set for boolean-ish columns.
BOOL_COLS = {
    "is_admin",
    "spoiler",
}

# Tables whose integer PK is named `id` and backed by a sequence in Postgres.
ID_SEQUENCE_TABLES = {
    "users",
    "epub_progress",
    "listening_progress",
    "bookmarks",
    "notes",
    "epub_bookmarks",
    "epub_notes",
    "feedback",
}


def sql_ident(name: str) -> str:
    # Keep it simple; our identifiers are safe.
    return '"' + name.replace('"', '""') + '"'


def sql_str(value: str) -> str:
    return "'" + value.replace("'", "''") + "'"


def sql_value(value: Any, column_name: str) -> str:
    if value is None:
        return "NULL"

    # sqlite3 returns int/float/str/bytes
    if isinstance(value, (int, float)):
        if column_name in BOOL_COLS and isinstance(value, int):
            return "TRUE" if value else "FALSE"
        return str(value)

    if isinstance(value, bytes):
        # Not expected in this app; encode as hex just in case.
        return "E'\\x" + value.hex() + "'"

    # Default: treat as text.
    text = str(value)
    if column_name in BOOL_COLS:
        lowered = text.strip().lower()
        if lowered in {"1", "true", "t", "yes"}:
            return "TRUE"
        if lowered in {"0", "false", "f", "no"}:
            return "FALSE"

    return sql_str(text)


def get_columns(conn: sqlite3.Connection, table: str) -> list[str]:
    rows = conn.execute(f"PRAGMA table_info({table})").fetchall()
    # row: (cid, name, type, notnull, dflt_value, pk)
    return [r[1] for r in rows]


def fetch_rows(conn: sqlite3.Connection, table: str, cols: list[str]) -> list[tuple[Any, ...]]:
    col_sql = ", ".join(sql_ident(c) for c in cols)
    return conn.execute(f"SELECT {col_sql} FROM {sql_ident(table)}").fetchall()


def build_insert_sql(table: str, cols: list[str], rows: list[tuple[Any, ...]]) -> str:
    if not rows:
        return ""

    cols_sql = ", ".join(sql_ident(c) for c in cols)

    values_sql_parts: list[str] = []
    for row in rows:
        vals = ", ".join(sql_value(v, cols[i]) for i, v in enumerate(row))
        values_sql_parts.append(f"({vals})")

    # Use ON CONFLICT DO NOTHING to make the import idempotent-ish.
    return f"INSERT INTO {sql_ident(table)} ({cols_sql})\nVALUES\n  " + ",\n  ".join(values_sql_parts) + "\nON CONFLICT DO NOTHING;\n"


def build_sequence_reset_sql(table: str) -> str:
    if table not in ID_SEQUENCE_TABLES:
        return ""
    # If the table has no rows, set sequence to 1.
    return (
        f"SELECT setval(pg_get_serial_sequence('{table}', 'id'), "
        f"COALESCE((SELECT MAX(id) FROM {sql_ident(table)}), 1));\n"
    )


def main() -> int:
    parser = argparse.ArgumentParser(description="Export SQLite data as SQL for Supabase/Postgres")
    parser.add_argument("--sqlite-path", default="backend/instance/app.db")
    parser.add_argument("--out", default="supabase_seed.sql")
    args = parser.parse_args()

    sqlite_path = Path(args.sqlite_path).expanduser().resolve()
    if not sqlite_path.exists():
        raise SystemExit(f"SQLite DB not found at: {sqlite_path}")

    out_path = Path(args.out).expanduser().resolve()

    conn = sqlite3.connect(str(sqlite_path))
    conn.row_factory = sqlite3.Row
    try:
        chunks: list[str] = []
        chunks.append("-- Generated by backend/export_sqlite_to_supabase_sql.py\n")
        chunks.append("-- Paste into Supabase SQL editor.\n")
        chunks.append("BEGIN;\n\n")
        chunks.append(
            "-- Optional: wipe existing data first (DANGEROUS).\n"
            "-- TRUNCATE TABLE feedback, epub_notes, epub_bookmarks, notes, bookmarks, listening_progress, epub_progress, users, invite_codes RESTART IDENTITY CASCADE;\n\n"
        )

        for table in TABLES_IN_FK_ORDER:
            cols = get_columns(conn, table)
            rows = fetch_rows(conn, table, cols)
            chunks.append(f"-- {table}: {len(rows)} row(s)\n")
            ins = build_insert_sql(table, cols, rows)
            if ins:
                chunks.append(ins)
            chunks.append("\n")

        chunks.append("-- Reset sequences (if you inserted explicit ids).\n")
        for table in TABLES_IN_FK_ORDER:
            seq = build_sequence_reset_sql(table)
            if seq:
                chunks.append(seq)
        chunks.append("\nCOMMIT;\n")

        out_path.write_text("".join(chunks), encoding="utf-8")
        print(f"Wrote: {out_path}")
        return 0
    finally:
        conn.close()


if __name__ == "__main__":
    raise SystemExit(main())
